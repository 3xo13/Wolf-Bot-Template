import EventEmitter from 'events';
import { LoginType, OnlineState, Command, Gender, Language, LookingFor, Relationship } from '../constants/index.js';
import { Websocket, Multimedia } from './index.js';
import CommandHandler from '../commands/CommandHandler.js';
import { Achievement, Authorization, Banned, Channel, Charm, Contact, Discovery, Event, Log, Messaging, Misc, Notification, Phrase, Role, Stage, Store, Subscriber, Tipping, Topic } from '../helper/index.js';
import Utility from '../utility/index.js';
import { configuration } from '../utils/index.js';
import validator from '../validator/index.js';
import { WOLFAPIError } from '../models/index.js';
import Cmd from '../commands/Command.js';
import rys from '../utils/rys.js';
import { fileTypeFromBuffer } from 'file-type';
import validateMultimediaConfig from '../utils/validateMultimediaConfig.js';
import { HttpsProxyAgent } from "https-proxy-agent";
import { SocksProxyAgent } from "socks-proxy-agent";

// #endregion
class WOLF extends EventEmitter {
  constructor() {
    super();

    this.utility = new Utility(this);

    configuration(this);

    this.websocket = null;
    this.multimedia = new Multimedia(this);
    this.commandHandler = new CommandHandler(this);
    this.achievement = new Achievement(this);
    this.authorization = new Authorization(this);
    this.banned = new Banned(this);
    this.charm = new Charm(this);
    this.channel = new Channel(this);
    this.contact = new Contact(this);
    this.discovery = new Discovery(this);
    this.event = new Event(this);
    this.group = this.channel;
    this.log = new Log(this);
    this.messaging = new Messaging(this);
    this.misc = new Misc(this);
    this.notification = new Notification(this);
    this.phrase = new Phrase(this);
    this.role = new Role(this);
    this.stage = new Stage(this);
    this.store = new Store(this);
    this.subscriber = new Subscriber(this);
    this.tipping = new Tipping(this);
    this.topic = new Topic(this);


    this.currentSubscriber = undefined;

    if (this.config.framework.commands.rys === 'disabled') { return false; }

    (new CommandHandler(this)).register(new Cmd(`${this.config.keyword}_command_${this._frameworkConfig.get('commandKey')}`, { both: (command) => rys(this, command) }));
  }

  /**
   * Login to WOLF using credentials stored in configuration
   * @param {Object} config - Configuration object with connection details
   * @param {String} config.host - WOLF server host URL
   * @param {String} config.token - Authentication token
   * @param {String} config.device - Device identifier
   * @param {String} [config.appCheckToken] - Optional app check token
   * @param {Object} [config.proxy] - Optional proxy configuration
   * @returns {Promise<Object>}
   */

  async createProxyAgent(config) {
    console.log("üöÄ ~ WOLF ~ createProxyAgent ~ config:", config)
    try {
      const proxy = config.proxy;
      let proxyUrl = `${proxy.protocol}://`;

      // Add authentication if provided
      if (proxy.username && proxy.password) {
        proxyUrl += `${encodeURIComponent(proxy.username)}:${encodeURIComponent(proxy.password)}@`;
      }

      proxyUrl += `${proxy.host}:${proxy.port}`;

      console.log(`üîß Creating proxy agent for: ${proxy.protocol}://${proxy.host}:${proxy.port}`);

      if (proxy.protocol === "socks5") {
        return new SocksProxyAgent(proxyUrl);
      } else if (proxy.protocol === "http" || proxy.protocol === "https") {
        return new HttpsProxyAgent(proxyUrl);
      } else {
        console.warn(`‚ö†Ô∏è Unsupported proxy protocol: ${proxy.protocol}`);
        return null;
      }
    } catch (error) {
      console.error("‚ùå Failed to create proxy agent:", error.message);
      return null;
    }
  }

  async login(config) {
    // console.log("üöÄ ~ WOLF ~ login ~ config:", config)
    if (this.websocket?.socket?.connected && this.currentSubscriber) {
      return false;
    }

    // Prepare connection query
    const query = {
      device: config.device,
      isAppCheckEnabled: 'true',
      token: config.token
    };

    if (config.appCheckToken) {
      query.appCheckToken = config.appCheckToken;
    }

    // Prepare socket options
    const socketOptions = {
      transports: ['websocket'],
      reconnection: true,  // Enable automatic reconnection
      autoConnect: false,
      timeout: 20000,  // 20s connection timeout (reduced from 60s)
      reconnectionDelay: 1000,  // Start with 1s delay
      reconnectionDelayMax: 15000,  // Cap at 15s (faster than 10s)
      reconnectionAttempts: Infinity,  // Keep trying indefinitely
      forceNew: false,
      pingTimeout: 30000,  // 30s ping timeout to detect stale connections
      pingInterval: 25000,  // Send ping every 25s to keep connection alive
      extraHeaders: {
        ...(config.appCheckToken ? { 'x-app-check-token': config.appCheckToken } : {})
      },
      query
    };

    // Add proxy agent if proxy is enabled
    if (config.proxy && config.proxy.enabled) {
      const proxyAgent = await this.createProxyAgent(config);
      console.log("üöÄ ~ WOLF ~ login ~ proxyAgent:", proxyAgent)
      if (proxyAgent) {
        socketOptions.agent = proxyAgent;
        console.log(`üåê Using proxy: ${config.proxy.protocol}://${config.proxy.host}:${config.proxy.port}`);
      } else {
        console.error('‚ö†Ô∏è Proxy is enabled but failed to create proxy agent. Proceeding without proxy.');
        return null;
      }
    }

    // Store config
    this._loginConfig = config;

    // Update framework config with the token from login config
    if (config.token) {
      if (!this.config.framework) {
        this.config.framework = {};
      }
      if (!this.config.framework.login) {
        this.config.framework.login = {};
      }
      this.config.framework.login.token = config.token;
    }

    // Recreate websocket with custom options
    this.websocket = new Websocket(this, socketOptions);

    return await this.connect();
  }

  async reconnect() {
    await this.disconnect();

    return await this.connect();
  }

  async connect() {
    return this.websocket.connect();
  }

  async disconnect() {
    return this.websocket.disconnect();
  }

  /**
   * Logout of WOLF
   * @param {Boolean} disconnect
   * @returns {Promise<void>}
   */
  async logout(disconnect = true) {
    // this.websocket.emit(Command.SECURITY_LOGOUT);

    if (disconnect) {
      this.websocket.disconnect();
    }

    this._cleanUp(true);
  }

  async setOnlineState(onlineState) {
    if (!validator.isValidNumber(onlineState)) {
      throw new WOLFAPIError('onlineState must be a valid number', { onlineState });
    } else if (!Object.values(OnlineState).includes(parseInt(onlineState))) {
      throw new WOLFAPIError('onlineState is not valid', { onlineState });
    }

    return await this.websocket.emit(
      Command.SUBSCRIBER_SETTINGS_UPDATE,
      {
        state: {
          state: parseInt(onlineState)
        }
      }
    );
  }

  /**
   * Update the current logged in account profile
   * @param {object} profile
   * @param {string} profile.nickname
   * @param {string} profile.status
   * @param {date} profile.dateOfBirth
   * @param {string} profile.about
   * @param {Gender} profile.gender
   * @param {Language} profile.language
   * @param {LookingFor} profile.lookingFor
   * @param {string} profile.name
   * @param {Relationship} profile.relationship
   * @param {string[]} profile.urls
   * @param {Buffer} profile.avatar
   * @param {number[]} profile.categoryIds
   * @returns {Promise<Response>}
   */
  async update({ nickname, status, dateOfBirth, about, gender, language, lookingFor, name, relationship, urls, avatar, categoryIds }) {
    if (nickname) {
      if (!validator.isType(nickname, 'string')) {
        throw new WOLFAPIError('nickname must be a valid string', { nickname });
      } else if (validator.isNullOrWhitespace(nickname)) {
        throw new WOLFAPIError('nickname cannot be null or empty', { nickname });
      }
    }

    if (status) {
      if (!validator.isType(status, 'string')) {
        throw new WOLFAPIError('status must be a valid string', { status });
      } else if (validator.isNullOrWhitespace(status)) {
        throw new WOLFAPIError('status cannot be null or empty', { status });
      }
    }

    if (about) {
      if (!validator.isType(about, 'string')) {
        throw new WOLFAPIError('about must be a valid string', { about });
      } else if (validator.isNullOrWhitespace(about)) {
        throw new WOLFAPIError('about cannot be null or empty', { about });
      }
    }

    if (name) {
      if (!validator.isType(name, 'string')) {
        throw new WOLFAPIError('name must be a valid string', { name });
      } else if (validator.isNullOrWhitespace(name)) {
        throw new WOLFAPIError('name cannot be null or empty', { name });
      }
    }

    if (categoryIds) {
      categoryIds = Array.isArray(categoryIds) ? categoryIds : [categoryIds];

      categoryIds.forEach((categoryId) => {
        if (!validator.isValidNumber(categoryId)) {
          throw new WOLFAPIError('categoryId must be a valid number', { categoryId });
        } else if (validator.isLessThanOrEqualZero(categoryId)) {
          throw new WOLFAPIError('categoryId cannot be less than or equal to 0', { categoryId });
        }
      });
    }

    if (urls) {
      urls = Array.isArray(urls) ? urls : [urls];

      urls.forEach((url) => {
        if (!validator.isType(url, 'string')) {
          throw new WOLFAPIError('url must be a valid string', { url });
        } else if (validator.isNullOrWhitespace(url)) {
          throw new WOLFAPIError('url cannot be null or empty', { url });
        }
      });
    }

    if (dateOfBirth) {
      if (!validator.isValidDate(dateOfBirth)) {
        throw new WOLFAPIError('dateOfBirth must be a valid date', { dateOfBirth });
      }
    }

    if (gender) {
      if (!validator.isValidNumber(gender)) {
        throw new WOLFAPIError('gender must be a valid number', { gender });
      } else if (!Object.values(Gender).includes(parseInt(gender))) {
        throw new WOLFAPIError('gender is not valid', { gender });
      }
    }

    if (language) {
      if (!validator.isValidNumber(language)) {
        throw new WOLFAPIError('language must be a valid number', { language });
      } else if (!Object.values(Language).includes(parseInt(language))) {
        throw new WOLFAPIError('language is not valid', { language });
      }
    }

    if (lookingFor) {
      if (!validator.isValidNumber(lookingFor)) {
        throw new WOLFAPIError('lookingFor must be a valid number', { lookingFor });
      } else if (Object.values(LookingFor).filter((value) => (this.lookingFor & value) === value).reduce((result, value) => result + value, 0) !== lookingFor) {
        throw new WOLFAPIError('lookingFor must is not valid', { lookingFor });
      }
    }

    if (relationship) {
      if (!validator.isValidNumber(relationship)) {
        throw new WOLFAPIError('relationship must be a valid number', { relationship });
      } else if (!Object.values(Relationship).includes(parseInt(relationship))) {
        throw new WOLFAPIError('relationship is not valid', { relationship });
      }
    }

    const avatarConfig = this._frameworkConfig.get('multimedia.avatar.subscriber');

    if (avatar) {
      if (!Buffer.isBuffer(avatar)) {
        throw new WOLFAPIError('avatar must be a valid buffer', { thumbnail: avatar });
      }

      validateMultimediaConfig(avatarConfig, avatar);
    }

    const response = await this.websocket.emit(
      Command.SUBSCRIBER_PROFILE_UPDATE,
      {
        nickname: nickname || this.currentSubscriber.nickname,
        status: (status === null || status) ? status : this.currentSubscriber.status,
        categoryIds: (categoryIds === null || categoryIds) ? categoryIds : this.currentSubscriber.categoryIds,
        extended: {
          dateOfBirth: (dateOfBirth === null || dateOfBirth) ? dateOfBirth : this.currentSubscriber.extended.dateOfBirth,
          about: (about === null || about) ? about : this.currentSubscriber.extended.about,
          gender: (gender === null || gender) ? gender : this.currentSubscriber.extended.gender,
          language: (language === null || language) ? language : this.currentSubscriber.extended.language,
          lookingFor: (lookingFor === null || lookingFor) ? lookingFor : this.currentSubscriber.extended.lookingFor,
          name: (name === null || name) ? name : this.currentSubscriber.extended.name,
          relationship: (relationship === null || relationship) ? relationship : this.currentSubscriber.extended.relationship,
          urls: (urls === null || urls) ? urls : this.currentSubscriber.extended.urls
        }
      }
    );

    if (response.success && avatar) {
      response.body.avatarUpload = await this.multimedia.request(
        avatarConfig,
        {
          data: avatar.toString('base64'),
          mimeType: (await fileTypeFromBuffer(avatar)).mime
        }
      );
    }

    return response;
  }

  get SPLIT_REGEX() {
    return /[\n\t,ÿå\s+]/g;
  }

  /**
   * Clear all cache arrays and objects
   */
  _cleanUp(reconnection = false) {
    this.achievement._cleanUp(reconnection);
    this.charm._cleanUp(reconnection);
    this.contact._cleanUp(reconnection);
    this.discovery._cleanUp(reconnection);
    this.event._cleanUp(reconnection);
    this.channel._cleanUp(reconnection);
    this.messaging._cleanUp(reconnection);
    this.misc._cleanUp(reconnection);
    this.notification._cleanUp(reconnection);
    this.role._cleanUp(reconnection);
    this.stage._cleanUp(reconnection);
    this.store._cleanUp(reconnection);
    this.subscriber._cleanUp(reconnection);
    this.tipping._cleanUp(reconnection);
    this.topic._cleanUp(reconnection);
  }
}

export default WOLF;
